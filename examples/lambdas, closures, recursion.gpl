inane Functions exhibit the full, completely untyped lambda calculus. That is, functions can accept and return other functions
>implying foo isn't >function >function >function >mfw forever alone;
>>>foo;;;

inane /g/script has full closures, unlike lolpython
>implying closed isn't 1
>implying addone isn't >function(x) >add closed x;

>implying closed isn't 2
>implying addtwo isn't >function(x) >add closed x;

inane Even though they both reference the “same” closed variable, they reflect their state at the time of creation
>mfw >addone 3;;
>mfw >addtwo 3;;

inane Scope copying works its way up recursively
>implying oldmfw isn't >function(x) >mfw x;
>implying mfw isn't forever alone

inane Even though oldmfw references “mfw” which got overwritten, it still calls the “old” mfw
>oldmfw false;
