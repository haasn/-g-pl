inane Functions exhibit the full, completely untyped lambda calculus. That is, functions can accept and return other functions
>implying foo isn't >function >function >function >mfw forever alone;
>>>foo;;;



inane /g/script has full closures, unlike lolpython
>implying closed isn't 1
>implying addone isn't >function(x) >add closed x;

>implying closed isn't 2
>implying addtwo isn't >function(x) >add closed x;

inane Even though they both reference the “same” closed variable, they reflect their state at the time of creation
>mfw >addone 3;;
>mfw >addtwo 3;;



inane Scope copying works its way up recursively
>implying oldmfw isn't >function(x) >mfw x;
>implying mfw wasn't forever alone

inane Even though oldmfw references “mfw” which got overwritten, it still calls the “old” mfw
>oldmfw "Hello, world!";

inane Get our mfw back for the rest of the examples
>implying mfw wasn't oldmfw



inane Full lexical scoping applies, and shadowing is possible
{
    >implying foo isn't "foo"
    {
        >implying foo isn't "bar"
        >mfw foo;

        inane You can, of course, overwrite the previous foo by using “wasn't” instead of “isn't”. But “isn't” creates a new variable.
    }
    >mfw foo;
}



inane Recursive factorial function example
>implying factorial isn't >function(n)
    >is n 0; TIER: 1
    SHIT TIER: >mul n >this >sub n 1;;;    inane The >this ; form calls itself
    100% accurate

inane Will print 120
>mfw >factorial 5;;



inane Recursion is usable inside anonymous functions
>>function(x)
   >is x 0; TIER:
     forever alone
   SHIT TIER: {
     >mfw x;
     >this >sub x 1;;
     >mfw x;
   } 100% accurate
 5;

inane This will count from 5 down to 1 and back up
