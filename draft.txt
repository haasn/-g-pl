= Prelude and Notes =

 Any and all of the names used here serve merely as placeholder and may or may not indicate their final form in
 whole or in part. Where no suitable suggestion was found, a descriptive placeholder was inserted for brevity.

 Where source code is introduced into this article, it is surrounded by a pair of backquotes (‘`’)
 Placeholders inside source code are surround by square brackets (‘[’ and ‘]’). A source code snippet containing
 placeholders may be followed by a section describing the nature of placeholders in the form “(name :: kind)”
 where name is the name of a placeholder, and kind describes what that placeholder may be (see Terminology section).
 If a placeholder is not mentioned, it is assumed to be anything. Multiple placeholder descriptions may be separated
 by a semicolon (‘;’).

= Terminology =

 Statement: Top level construct with special, well-defined behavior. May consist of further statements
 Expression: An evaluatable snippet which consists of further expressions and produces a single result
 Block: An evaluatable snippet which consists of unconnected statements and is itself a statement
 Comment: A portion of code that is ignored completely and does not influence execution in any way
 Name: A variable name which may not be any of the reserved symbols and must start with a non-decimal (see below)
 Newline: Any non-empty combination of \r and \n that may be surrounded by any amount of whitespace
 Variable: A construct that is given a value, name, type and scope; whose value may be reassigned
 Free variable: A variable for which the scope is unclear or undefined
 Uninitialized variable: A variable for which the value and type are unclear or undefined
 Scope: A collection of variables assigned to a statement
 Fatal error: An error message that, in addition to alerting the user, immediately terminates the entire program
 Type: Any of four intrinsic data types, see Types section below
 Condition: Any expression which gives a result of type boolean

= Style and Format =

 Intrinsic statements are separated by a terminator which is a newline as described above. All source files are
 explicitly UTF-8, and all names may include special UTF runes provided they are not in the group of whitespace
 or control characters.

 Names may NOT start with a digit from 0 to 9, a minus sign (‘-’), a period (‘.’) or a quote (‘"’), in addition to
 the forbidden runes described in the previous paragraph. The name regex looks like this: /[^-."\d\s\cA-\cZ][^\s\cA-\cZ]*/

= Comments =

 A single line comment may be introduced by “inane” and extends to the next newline. A multi-line comment
 may be introduced by the special “I'd like to interject” keyword and terminated with “Linux”. If, for any
 reason, the “Linux” word wants to be taken as a literal, it may be escaped by the special form “GNU/Linux”
 which will not terminate the comment.

 `inane [comment]`
 `I'd like to interject [comment] Linux`

= Variables =

 All variables must be bound at all times, any usage of a free variable will result in a fatal error.
 A variable can be introduced into the current scope with an “implying” statement, which has several possible
 forms that are governed by special rules:

 `>implying [name] isn't [value]` (name :: Name; value :: Expression)
 This form will create a variable named [name] in the current scope, set its value to [value], set its type
 depending on the nature of [value] as governed by the rules in the Expressions section

 `>implying <name>` (name :: Name)
 This form will create an unitialized variable named [name] in the current scope.

 A variable may be assigned to using the following form:
 `>implying [name] wasn't [value]` (name :: Name; value :: Expression)
 This distinguishes itself from the previous form (with “isn't” instead of “wasn't”) in that this form recursively
 traverses the current scope outwards until it finds the first occurence of a variable named [name], then
 changes the value of that variable. In case no such variable is found, a fatal error shall occur.

= Types =

 There are exactly six intrinsic data types: Integer, Float, Boolean, String, Function{...} and Forever Alone

 == Integer ==

  An integer is a member of ℤ, that is the set of all non-negative natural numbers ℕ⁰ plus the inversion of ℕ*.
  Integers are formally required to be unlimited in magnitude (that is, potentially infinite), but for the sake
  of convenience an implementation may restrict this to the maximal machine integer size on a given architecture.

 == Float ==

  A float is a floating point number as defined by IEEE 754. The special forms are “Infinity”, “-Infinity” and “NaN”.
  These are taken to be the maximum available machine floating point precision available on a given architecture.

 == Boolean ==

  A boolean is a type with two possible states, “true” or “false”. These have two acceptable alternative forms:
  “on” and “off” as well as “yes” and “no”. All of these are synonyms for the same notion and hold no difference.

 == String ==

  A string is a sequence of Unicode runes. There is no data type for a single rune, a string with length 1 is used
  instead.

 == Function{...} ==

  These represent untyped functions that can be called. The “...” represents a listing of arguments separated by
  whitespace. A function type could look like “function{x y}” or “function{bar}”.

 == Forever Alone ==

  A forever alone type represents a type which has only one acceptable value: forever alone. A function may return
  a forever alone to indicate the lack of a return value. The type forever alone and the value forever alone can be
  interchanged freely, as they are inseparable.

 Some types may be represented directly using a special literal form, represented here using a regular expression:

 Integer: /-?\d+/
 Float: /-?\d*\.\d+/
 String: /"(\\"|[^\\"]|\\\\)+"/
 Boolean: /true|false|on|off|yes|no/

 These are designed to be unambiguous, that is, there is no single input which matches more than one form. Type
 literals are expressions. The types which have no literals may not be literally created (but may be obtained via
 other means, for example a blank “gb2” and the “>function{...}” statement)

 == Type inference rules ==

  Any expression produces both a value and a type for that value. These types cannot be implicitly converted or
  casted with one exception: An integer may freely be converted to a float if required. This is useful to, for
  example, infer floating point precision. See the rules on Expressions to find out which expressions require
  which types.

  For general conversions, there exist built-in functions “floor”, “ceil” and “round” to convert a float into
  an integer, and “float” to convert an integer into a float (and warn if a float is given).

= Expressions =



= Functions =

 Functions may be created using the following syntax:

 `>function{[name...]} [body]` (name :: Name; body :: Statement)

 Functions may be called using the following syntax:
 `>[name] [parameter...]` (name :: Name, that is a known function; parameters :: Expression)

 A function call's parameters, as well as the name and the first parameter, may be separated by any sort of
 whitespace including tabs, newlines and spaces. They are only considered to be terminated when the function's
 required number of parameters have been given. So, for example, if “foo” takes two parameters and “bar” takes one,
 `>foo >bar bat baz`
  and
 `>foo
    >bar bat
    baz`
 represent the same function call. Function calls and creations are expressions.

 What happens when you call a function is that a new scope is created /inside/ the variable containing the function's
 containing scope, with each of the named parameters being created with the type and value of the parameter's
 expression.

 Attempting to call a variable that is not a function (eg. an integer or a string) will result in a fatal error.

= gb2 statement =

 The “gb2” statement has the form:
 `gb2 [value]` (value :: Expression)
 and, when used inside the execution of a function, evaluates [value] and returns its value + type to the parent
 context (see the Expressions section on the rules governing intermediate values). If used without a [value], it
 returns a value of type forever alone.
 
= TIER statement =

 The “TIER” statement has the form:

 `[cond1] TIER:
      [res1]
  [cond2] TIER:
      [res2]
  100% accurate` (condn :: Condition; resn :: Statement)
  
 and its effect is to evaluate one and only one of the resulting [resn] blocks, depending on which [condn] first
 returns a result of “true”, as processed in a top-down order.

 Nested TIER statements can be indicated with the special keyword “furthermore”, for example:

 `>implying foo isn't 5
  foo is 5 TIER:
      >mfw "right"
      furthermore,
      foo below 4 TIER:
          >mfw "but that's where you're wrong"
      foo above 4 TIER:
        >mfw "OP is a reasonable person"
      100% accurate
  foo is 2 TIER:
      >mfw "you're wrong"
  100% accurate`
