= Prelude and Notes =

 Any and all of the names used here serve merely as placeholder and may or may not indicate their final form in
 whole or in part. Where no suitable suggestion was found, a descriptive placeholder was inserted for brevity.

 Where source code is introduced into this article, it is surrounded by a pair of backquotes (‘`’)
 Placeholders inside source code are surround by square brackets (‘[’ and ‘]’). A source code snippet containing
 placeholders may be followed by a section describing the nature of placeholders in the form “(name :: kind)”
 where name is the name of a placeholder, and kind describes what that placeholder may be (see Terminology section).
 If a placeholder is not mentioned, it is assumed to be anything. Multiple placeholder descriptions may be separated
 by a semicolon (‘;’).

= Terminology =

 Expression: An evaluatable snippet which produces a single result (value + type)
 Block: An expression which consists of further expressions, executed in order
 Comment: A portion of code that is ignored completely and does not influence execution in any way
 Name: A variable name which may not be any of the reserved symbols and must start with a non-decimal (see below)
 Newline: Any non-empty combination of \r and \n that may be surrounded by any amount of whitespace
 Variable: A construct that is given a value, name, type and scope; whose value may be reassigned
 Free variable: A variable for which the scope is unclear or undefined
 Uninitialized variable: A variable for which the value and type are unclear or undefined
 Scope: A collection of variables assigned to a statement
 Fatal error: An error message that, in addition to alerting the user, immediately terminates the entire program
 Type: Any of four intrinsic data types, see Types section below
 Condition: Any expression which gives a result of type boolean

= Style and Format =

 Intrinsic expressions are separated by a terminator which is a newline as described above. All source files are
 explicitly UTF-8, and all names may include special UTF runes provided they are not in the group of whitespace
 or control characters.

 Names may NOT start with a digit from 0 to 9, a minus sign (‘-’), a period (‘.’) or a quote (‘"’), in addition to
 the forbidden runes described in the previous paragraph. The name regex looks like this: /[^-."\d\s\cA-\cZ][^\s\cA-\cZ]*/

= Comments =

 A single line comment may be introduced by “inane” and extends to the next newline. A multi-line comment
 may be introduced by the special “I'd like to interject” keyword and terminated with “Linux”. If, for any
 reason, the “Linux” word wants to be taken as a literal, it may be escaped by the special form “GNU/Linux”
 which will not terminate the comment.

 `inane [comment]`
 `I'd like to interject [comment] Linux`

= Variables =

 All variables must be bound at all times, any usage of a free variable will result in a fatal error.
 A variable can be introduced into the current scope with an “implying” expression, which has several possible
 forms that are governed by special rules:

 `>implying [name] isn't [value]` (name :: Name; value :: Expression)
 This form will create a variable named [name] in the current scope, set its value to [value], set its type
 depending on the nature of [value] as governed by the rules in the Expressions section

 `>implying <name>` (name :: Name)
 This form will create an unitialized variable named [name] in the current scope.

 A variable may be assigned to using the following form:
 `>implying [name] wasn't [value]` (name :: Name; value :: Expression)
 This distinguishes itself from the previous form (with “isn't” instead of “wasn't”) in that this form recursively
 traverses the current scope outwards until it finds the first occurence of a variable named [name], then
 changes the value of that variable. In case no such variable is found, a fatal error shall occur.

 The result of an “>implying” expressions will be the value and type of the assigned variable, or in the case
 of an uninitialized creation, a “forever alone”.

= Types =

 There are exactly six intrinsic data types: Integer, Float, Boolean, String, Function{...} and Forever Alone

 == Integer ==

  An integer is a member of ℤ, that is the set of all non-negative natural numbers ℕ⁰ plus the inversion of ℕ*.
  Integers are formally required to be unlimited in magnitude (that is, potentially infinite), but for the sake
  of convenience an implementation may restrict this to the maximal machine integer size on a given architecture.

 == Float ==

  A float is a floating point number as defined by IEEE 754. The special forms are “Infinity”, “-Infinity” and “NaN”.
  These are taken to be the maximum available machine floating point precision available on a given architecture.

 == Boolean ==

  A boolean is a type with two possible states, “true” or “false”. These have two acceptable alternative forms:
  “on” and “off” as well as “yes” and “no”. All of these are synonyms for the same notion and hold no difference.

 == String ==

  A string is a sequence of Unicode runes. There is no data type for a single rune, a string with length 1 is used
  instead.

 == Function{...} ==

  These represent untyped functions that can be called. The “...” represents a listing of arguments separated by
  whitespace. A function type could look like “function{x y}” or “function{bar}”. A function has one distinction
  that makes it special: It carries with it another scope, a so-called “execution scope”. This information is
  implicit and implementation-bound, there is no way to retrieve or modify this from within the language itself.

  See the functions section for more information.

 == Forever Alone ==

  A forever alone type represents a type which has only one acceptable value: forever alone. A function may return
  a forever alone to indicate the lack of a return value. The type forever alone and the value forever alone can be
  interchanged freely, as they are inseparable.

 Some types may be represented directly using a special literal form, represented here using a regular expression:

 Integer: /-?\d+/
 Float: /-?\d*\.\d+/
 String: /"(\\"|[^\\"]|\\\\)+"/
 Boolean: /true|false|on|off|yes|no/
 Forever Alone: /forever alone/

 These are designed to be unambiguous, that is, there is no single input which matches more than one form. Type
 literals are expressions. Boolean and Forever Alone literals are case sensitive.

 == Type inference rules ==

  Any expression produces both a value and a type for that value. These types cannot be implicitly converted or
  casted with one exception: An integer may freely be converted to a float if required. This is useful to, for
  example, infer floating point precision. See the rules on Expressions to find out which expressions require
  which types.

  For general conversions, there exist built-in functions “floor”, “ceil” and “round” to convert a float into
  an integer, and “float” to convert an integer into a float (and warn if a float is given).

= Expressions =

 Expressions are evaluatable portions of code which produce a value and a type.

= Functions =

 Functions may be created using the following syntax:

 `>function([name...]) [body]` (name :: Name; body :: Expression)

 If the () is empty, it may be omitted - so `>function [body]` is the same as `>function() [body]`

 Functions may be called using the following syntax:
 `>[name] [parameter...]` (name :: Name, that is a known function; parameters :: Expression)

 A function call's parameters, as well as the name and the first parameter, may be separated by any sort of
 whitespace including tabs, newlines and spaces. They are only considered to be terminated when the function's
 required number of parameters have been given. So, for example, if “foo” takes two parameters and “bar” takes one,
 `>foo >bar bat baz`
  and
 `>foo
    >bar bat
    baz`
 represent the same function call. Function calls and creations are expressions.

 Functions, as mentioned above, carry with them a special scope. When a function is created, their scope is assigned
 the current scope in which they were created. If this function gets passed elsewhere, that scope gets passed along with
 them.

 What happens when you call a function is that a new scope is created /inside/ the function's execution scope,
 with each of the named parameters being created there with the type and value of the parameter's expression.

 If you result an intermediate function directly, eg. `>>function(x) gb2 >+ x x 5`, what happens is that the intermediate
 value of the first expression (“>function(x) gb2 >+ x x”), which carries with it a special scope (that is not normally
 known for expressions but was assigned during its creation) is executed immediately as detailed above. This means that
 a new scope is created inside the function's execution scope (which is the current), with the Integer “x” set to “5”.

 “gb2 >+ x x” is then evaluated as normal inside that scope, which means that the closest bound ‘x’, in this case the
 one inside its own scope, gets added to itself, and the result of that expression gets returned via the “gb2”.

 So writing `>mfw >>function(x) gb2 >+ x x 5` will output a “10”.

 Attempting to call a variable that is not a function (eg. an integer or a string) will result in a fatal error.
 
= TIER expression =

 The “TIER” expression has the form:

 `[cond1] TIER: [res1]
  [cond2] TIER: [res2]` (condn :: Condition; resn :: Expression)
  
 and its effect is to evaluate one and only one of the resulting [resn] blocks, depending on which [condn] first
 returns a result of “true”, as processed in a top-down order.

 Examples:

 `>implying foo isn't 5
  foo is 5 TIER: {
      >mfw "right"
      foo below 4 TIER: >mfw "but that's where you're wrong"
      foo above 4 TIER: >mfw "OP is a reasonable person"
  }
  foo is 2 TIER:
      >mfw "you're wrong"`
 
 TIERs need no terminator, as they hold only one expression. If you wish to chain multiple, a block may be used.

= Block expression =

 A block expression is written as `{[block...]}` (block :: Expression) and can be used to chain multiple expressions
 together. So, for example, a function which would output "hello" followed by "world" could look like this:

 `>implying foo isn't >function {>mfw "hello" >mfw "World"}`

 Or, with newlines added:

 `>implying foo isn't >function {
      >mfw "hello"
      >mfw "world"
  }`

 By default, they return a “Forever Alone”, unless they include a “gb2” expression somewhere, in which case the blocks
 return execution at that point.

 An example of this usage could be:
 `>mfw {
      >mfw "hello"
      gb2 "world"
  }`

 This would print out "hello" followed by "world".

 == gb2 expression ==

  The “gb2” expression has the form:
  `gb2 [value]` (value :: Expression)
  and, when used inside the execution of a block, evaluates [value] and returns it. If used without a [value], it
  returns a value of type forever alone.
